
/**
 * Copyright (C) 2017  Ardika Rommy Sanjaya
 */

buildscript {

    apply from: "${rootDir}/gradle/configure.gradle"

    repositories {
        jcenter()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

}

plugins {
    id "java"
    id "signing"
    id "maven"
    id "jacoco"
    id "checkstyle"
    id "pmd"
    id "org.springframework.boot" version "2.0.4.RELEASE" apply false
    id "com.jfrog.bintray" version "1.7.3" apply false
    id "com.github.spotbugs" version "1.6.2" apply false
    id "com.github.kt3k.coveralls" version "2.8.2" apply false
    id "co.riiid.gradle" version "0.4.2" apply false
}

apply plugin: 'java'

group = "${GROUP}"
version = "${VERSION}"

subprojects {

    apply plugin: 'java'
    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'jacoco'
    apply plugin: 'com.github.kt3k.coveralls'

    group = rootProject.group
    version = rootProject.version

    sourceCompatibility = "${JAVA_VERSION}"
    targetCompatibility = "${JAVA_VERSION}"

    [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

    repositories {
        mavenCentral()
        jcenter()
        maven {
            url 'https://dl.bintray.com/ardikars/maven'
        }
    }

    dependencyManagement {
        imports { mavenBom("com.ardikars.common:common:${COMMON_VERSION}") }
        imports { mavenBom("io.netty:netty-bom:${NETTY_VERSION}") }
    }

    dependencies {
        implementation ("com.ardikars.common:common-net")
        implementation ("com.ardikars.common:common-util")
        implementation ("io.netty:netty-buffer")
        testImplementation ('junit:junit:4.12')
    }

    configurations.archives.artifacts.with { archives ->
        def jarArtifact
        archives.each {
            if (it.file =~ 'jar' && project.name == "${rootProject.name}") {
                jarArtifact = it
            }
        }
        remove(jarArtifact)
    }

    evaluationDependsOn(project.path)

    jar {
        manifest {
            attributes 'Implementation-Title': 'Jxnet',
                    'Implementation-Version': version
        }
    }

    javadoc {
        def currentYear = Calendar.getInstance().get Calendar.YEAR
        options.with {
            locale 'en_US'
            encoding 'UTF-8'
            charSet 'UTF-8'
            author true
            windowTitle "${NAME} ${project.version}"
            header "${NAME} ${project.version}"
            docTitle "${NAME} ${project.version} API Documentation"
            footer 'https://github.com/jxnet/Jxpacket'
            bottom "Copyright &copy; 2017 - ${currentYear} ardikars.com. All rights reserved."
            showFromProtected()
            addStringOption 'Xdoclint:all,-reference', '-quiet'
        }
    }

    task javadocJar(type: Jar) {
        classifier = 'javadoc'
        from javadoc
    }

    task sourcesJar(type: Jar) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    tasks.withType(JavaCompile) {
        //options.compilerArgs << "-Xlint:unchecked" << "-Werror"
    }

    jacoco {
        toolVersion = "${JACOCO_VERSION}"
    }

    jacocoTestReport {
        reports {
            xml.enabled true
            csv.enabled false
            html.destination file("${buildDir}/jacocoHtml")
        }
    }

    test {
        testLogging {
            showStandardStreams = true
        }
        jacoco {
            append = false
            destinationFile = file("$buildDir/jacoco/jacocoTest.exec")
            classDumpDir = file("$buildDir/jacoco/classpathdumps")
        }
    }

    clean {
        file("${rootDir}/${project.name}/obj").deleteDir()
        file("${rootDir}/${project.name}/out").deleteDir()
    }

    /**
     * Upload converage report
     */
    tasks.coveralls {
        dependsOn 'check'
    }

}

if (gradle.startParameter.taskNames.contains('github') ||
        gradle.startParameter.taskNames.contains('githubRelease')) {
    apply from: 'gradle/githubRelease.gradle'
}

if (gradle.startParameter.taskNames.contains('github') ||
        gradle.startParameter.taskNames.contains('githubRelease')) {
    apply from: 'gradle/githubRelease.gradle'
}

if (gradle.startParameter.taskNames.contains("install")) {
    apply from: 'gradle/artifactInstall.gradle'
}

if (gradle.startParameter.taskNames.contains("dist")) {
    apply from: 'gradle/artifactDistribute.gradle'
}

if (gradle.startParameter.taskNames.contains("build")) {
//    apply from: 'gradle/codeAnalysis.gradle'
}

if (gradle.startParameter.taskNames.contains("bintrayUpload") ||
        gradle.startParameter.taskNames.contains("uploadArchives")) {
    apply from: 'gradle/artifactRelease.gradle'
}

task wrapper(type: Wrapper) {
    distributionUrl = "https://services.gradle.org/distributions/gradle-${GRADLE_VERSION}-all.zip"
}
